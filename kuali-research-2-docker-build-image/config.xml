<?xml version='1.0' encoding='UTF-8'?>
<project>
  <actions/>
  <description>This job creates a kuali-research docker image, wrapping a specified war file into it.</description>
  <keepDependencies>false</keepDependencies>
  <properties>
    <jenkins.model.BuildDiscarderProperty>
      <strategy class="hudson.tasks.LogRotator">
        <daysToKeep>-1</daysToKeep>
        <numToKeep>5</numToKeep>
        <artifactDaysToKeep>-1</artifactDaysToKeep>
        <artifactNumToKeep>-1</artifactNumToKeep>
      </strategy>
    </jenkins.model.BuildDiscarderProperty>
    <hudson.model.ParametersDefinitionProperty>
      <parameterDefinitions>
        <hudson.model.StringParameterDefinition>
          <name>JENKINS_WAR_URL</name>
          <description>The location of the war file within the jenkins website.
Example: http://localhost:8080/job/kuali-research-1-build-war/ws/coeus-webapp/target/coeus-webapp-1603.50-SNAPSHOT.war	
(NOTE: This must start with http:// to indicate the protocol being used to the ADD instruction in the docker file.</description>
          <defaultValue></defaultValue>
        </hudson.model.StringParameterDefinition>
        <hudson.model.StringParameterDefinition>
          <name>POM_VERSION</name>
          <description>The maven version number for the war file the docker image being built is based on.
Example: 1603.50-SNAPSHOT</description>
          <defaultValue></defaultValue>
        </hudson.model.StringParameterDefinition>
        <hudson.model.StringParameterDefinition>
          <name>REGISTRY_REPO_NAME</name>
          <description>This value comes from maven artifact id (except for sandbox builds).
This is used to identify the name of the docker registry repository that this image is going to be pushed to.
The value is &quot;coeus&quot; by default, but remember that any sandbox images should go to a registry repository called &quot;coeus-sandbox&quot;</description>
          <defaultValue>coeus</defaultValue>
        </hudson.model.StringParameterDefinition>
        <hudson.model.StringParameterDefinition>
          <name>ECR_REGISTRY_URL</name>
          <description>The url of the elastic container registry (ECR) where the newly created image is to be pushed to from this server and pulled from by the target docker host for the image wrapping the newly built war file.</description>
          <defaultValue>730096353738.dkr.ecr.us-east-1.amazonaws.com</defaultValue>
        </hudson.model.StringParameterDefinition>
        <hudson.model.StringParameterDefinition>
          <name>DOCKER_BUILD_CONTEXT_GIT_BRANCH</name>
          <description>You can modify this value to pull a build context stored in a branch other than master.</description>
          <defaultValue>apache</defaultValue>
        </hudson.model.StringParameterDefinition>
      </parameterDefinitions>
    </hudson.model.ParametersDefinitionProperty>
  </properties>
  <scm class="hudson.scm.NullSCM"/>
  <canRoam>true</canRoam>
  <disabled>false</disabled>
  <blockBuildWhenDownstreamBuilding>false</blockBuildWhenDownstreamBuilding>
  <blockBuildWhenUpstreamBuilding>false</blockBuildWhenUpstreamBuilding>
  <triggers/>
  <concurrentBuild>false</concurrentBuild>
  <builders>
    <hudson.tasks.Shell>
      <command># 1) Remove any dangling items
if [ -n &quot;$(docker images --filter dangling=true -q)&quot; ] ; then 
   docker rmi -f $(docker images --filter dangling=true -q); 
   echo &quot;Removed dangling image(s)&quot;;
else
   echo &quot;No dangling images to remove&quot;;
fi
if [ -n &quot;$(docker volume ls -qf dangling=true)&quot; ] ; then 
   docker volume rm $(docker volume ls -qf dangling=true); 
   echo &quot;Removed dangling volume(s)&quot;;
else 
   echo &quot;No dangling volumes to remove&quot;;
fi

# 2) If the base tomcat image is not in the local repo, get it from the registry
TOMCAT_REGISTRY_IMAGE=&quot;${ECR_REGISTRY_URL}/centos7-java-tomcat:latest&quot;
TOMCAT_LOCAL_IMAGE=&quot;bu-ist/centos7-java-tomcat:latest&quot;
if [ -z &quot;$(docker images -q ${TOMCAT_LOCAL_IMAGE})&quot; ]; then
   echo &quot;CANNOT FIND DOCKER IMAGE: ${TOMCAT_LOCAL_IMAGE}&quot;;
   if [ -z &quot;$(docker images -q ${TOMCAT_REGISTRY_IMAGE})&quot; ]; then 
      echo &quot;CANNOT FIND DOCKER IMAGE: ${TOMCAT_REGISTRY_IMAGE}&quot;; 
      echo &quot;Pulling ${TOMCAT_REGISTRY_IMAGE} from registry...&quot;
      eval $(aws ecr get-login --profile ecr.access)
      docker pull ${TOMCAT_REGISTRY_IMAGE}
   fi
   echo &quot;Tagging ${TOMCAT_REGISTRY_IMAGE}&quot;
   docker tag ${TOMCAT_REGISTRY_IMAGE} ${TOMCAT_LOCAL_IMAGE}
fi

# 3) Define variables.
# NOTE: JENKINS_URL is the full URL of Jenkins, like http://server:port/jenkins/ 
#       Only available if Jenkins URL is set in system configuration
ECR_REPO_URL=&quot;${ECR_REGISTRY_URL}/${REGISTRY_REPO_NAME}&quot;
DOCKER_TAG=&quot;${ECR_REPO_URL}:${POM_VERSION}&quot;
DOCKER_BUILD_CONTEXT=&quot;git@github.com:bu-ist/kuali-research-docker.git#${DOCKER_BUILD_CONTEXT_GIT_BRANCH}:kuali-research/build.context&quot;

# 4) Build the app image (the image will curl the jenkins war artifact into itself while it is building).
eval `ssh-agent -s`
# We cannot execute the ADD instruction in the Dockerfile against $SOURCE_WAR because we are implementing
# Jenkins security and docker gets challenged for authentication while trying to the war file from this
# link. The ADD instruction does not support authentication and I have not been able to make wget or curl 
# with authentication work from a RUN instruction within the Dockerfile for this same link.
# Therefore we must get our war file into the build context manually where we can use ADD (or COPY) with 
# a relative file location.
# Therefore, the standard docker build command with a context referring to a git repo also cannot be used
# because it clones the build context to some unknown directory in /tmp.
# Therefore, we will checkout the build context to a known location within the jenkins build context, copy
# our war file to it, and then execute the docker build command.
#
# so...
# commenting out the original build command
# docker build -t ${DOCKER_TAG} --build-arg SOURCE_WAR=${JENKINS_WAR_URL} ${DOCKER_BUILD_CONTEXT}
#
# and...
# adding the manual approach
ssh-add ~/.ssh/bu_github_id_docker_rsa
if [ -d kuali-research-docker ] ; then
   rm -f -r kuali-research-docker
fi
mkdir kuali-research-docker
cd kuali-research-docker
git init	
git config user.email &quot;jenkins@bu.edu&quot;
git config user.name jenkins
git config core.sparseCheckout true
git remote add github git@github.com:bu-ist/kuali-research-docker.git
echo kuali-research &gt;&gt; .git/info/sparse-checkout
git fetch github apache
git checkout apache 
eval `ssh-agent -k`
TARGET_DIR=${JENKINS_HOME}/workspace/kuali-research-1-build-war/coeus-webapp/target
cp ${TARGET_DIR}/*.war kuali-research/build.context
WAR_FILE=$(ls -q ${TARGET_DIR}/*.war)

docker build -t ${DOCKER_TAG} --build-arg SOURCE_WAR=${WAR_FILE} kuali-research/build.context
</command>
    </hudson.tasks.Shell>
  </builders>
  <publishers/>
  <buildWrappers/>
</project>